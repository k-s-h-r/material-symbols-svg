# アーキテクチャとリファクタリング計画

## 1. 背景と問題点

当初のビルドプロセスでは、アイコン、スタイル、ウェイトの全ての組み合わせごとに個別のファイルを生成していました。その結果、ファイル数は14万を超え、パッケージの合計サイズは1GBに達し、npmレジストリへの公開が不可能な状態でした。

## 2. 目標

このリファクタリングの主な目的は、ファイル数とパッケージサイズを公開可能なレベルまで劇的に削減し、同時に以下の目標を達成することです。

- **優れた開発者体験 (DX):** ユーザーにシンプルで直感的、かつ一貫性のあるAPIを提供する。
- **完璧なTree-shaking:** ユーザーが明示的にインポートしたアイコンとバリアントのコードのみが、最終的なバンドルに含まれるようにする。
- **最適化されたパッケージサイズ:** 特に通常版（regular）と塗りつぶし版（filled）のアイコンバリアント間で、全ての冗長なデータを排除する。
- **メンテナンス性の高いコードベース:** 複雑なロジックをビルドスクリプトに集約し、生成されるライブラリのコードはクリーンで単純な状態に保つ。

## 3. 最終的なアーキテクチャ

私たちは、モノレポ構成と、インテリジェントなデータ駆動型ビルドプロセスを組み合わせた、洗練されたハイブリッドアーキテクチャを採用します。

### 3.1. pnpmによるモノレポ構成

プロジェクトをpnpmワークスペースを利用したモノレポに移行します。これにより、ライブラリをスタイルごとに分割し、ユーザーが必要なものだけをインストールできるようになります。

```
/
├─ packages/
│  ├─ react/         (@material-symbols-svg/react, "outlined" スタイル用)
│  ├─ react-rounded/ (@material-symbols-svg/react-rounded, "rounded" スタイル用)
│  └─ react-sharp/   (@material-symbols-svg/react-sharp, "sharp" スタイル用)
├─ scripts/                          (共有ビルドスクリプト)
├─ package.json                      (ルートのpnpmワークスペース設定)
└─ ARCHITECTURE.md                   (このファイル)
```

### 3.2. 基本ビルド戦略：1アイコン = 1ファイル

ビルドスクリプトは、アイコンごとに1つのTypeScriptファイル（例: `home.ts`, `settings.ts`）を生成します。このファイルが、そのアイコンに関する唯一の信頼できる情報源（Source of Truth）となります。

- **合計ファイル数:** 1パッケージあたり約3,340ファイルとなり、許容範囲内に収まります。

### 3.3. インテリジェントなデータ重複排除（「Fill」ロジック）

これが最適化の核心です。ビルドスクリプトは、通常版と塗りつぶし版のバリアントをインテリジェントに処理します。

1.  **SVGパスの比較:** アイコンごとに、7つのウェイト全てにおいて、通常版と塗りつぶし版のSVGパスデータを比較します。
2.  **条件付きデータ格納:**
    - **パスが1つでも異なる場合:** アイコンファイル（`.ts`）には、通常版と塗りつぶし版の**両方**のパスデータを格納します。
    - **全てのパスが同一の場合:** アイコンファイルには、**通常版のパスデータのみ**を格納します。
3.  **コンポーネント生成:**
    - 通常版と塗りつぶし版（Fill）のコンポーネントは完全に独立したアイコンとして生成されます。
    - 両方のコンポーネントとも標準的な `fill="currentColor"` で色がつきます。
    - パスが同一の場合でも、通常版とFill版は別々のコンポーネントとして生成されます。

このプロセスにより、最終的なパッケージにおいてデータの冗長性がゼロになり、かつその処理はエンドユーザーから見て完全に透過的になります。

### 3.4. DXとTree-Shakingの共存

「仮想エントリーポイント」戦略を用いることで、シンプルなAPIと完璧なTree-shakingの両立を実現します。

1.  **信頼できる情報源（Source of Truth）:** 各アイコンファイル（例: `icons/home.ts`）は、全てのバリアントをユニークな内部名（例: `HomeW100`, `HomeFilledW100`）でエクスポートします。スタイル名はパッケージで表現されるため、コンポーネント名には含めません。
2.  **仮想エントリーポイント:** ビルドスクリプトは、ウェイトごとにファイル（例: `w100.ts`, `w400.ts`）を生成します。これらのファイルは、アイコンファイルからコンポーネントを、シンプルでユーザーフレンドリーな名前で再エクスポートします。
    ```typescript
    // 自動生成されるファイル: src/outlined/w100.ts
    export { HomeOutlinedW100 as Home, HomeFilledOutlinedW100 as HomeFill } from '../icons/home';
    export { SettingsOutlinedW100 as Settings, SettingsFilledOutlinedW100 as SettingsFill } from '../icons/settings';
    // ... 全てのアイコンについて同様に続く
    ```
3.  **`package.json`の`exports`マップ:** 各パッケージの`package.json`は、ユーザーフレンドリーなインポートパスを、生成されたこれらのエントリーポイントにマッピングします。
    ```json
    // packages/material-symbols-svg-react/package.json
    "exports": {
      ".": "./dist/w400.js", // デフォルトインポート
      "./w100": "./dist/w100.js",
      "./w200": "./dist/w200.js",
      // ...
      "./icons/*": "./dist/icons/*.js" // アイコンへの直接アクセス用
    }
    ```

この設定により、ユーザーは直感的なコードを書くことができ、一方でバンドラはインポートの依存関係を特定のTree-shaking可能なコンポーネントとその最小限の必須データまで正確に追跡できます。

## 4. 最終的なユーザー向けAPI

```jsx
// "Home"のW700, outlinedバージョンが欲しい場合
import { Home, HomeFill } from '@material-symbols-svg/react/w700';

// "Settings"のデフォルトウェイト(400), roundedバージョンが欲しい場合
import { Settings, SettingsFill } from '@material-symbols-svg/react-rounded';

function MyComponent() {
  return (
    <div>
      <Home />
      <SettingsFill />
    </div>
  );
}
```

## 5. 実行計画

1.  **pnpmとモノレポのセットアップ:** pnpmワークスペースを初期化し、プロジェクトのディレクトリ構造を再構築する。
2.  **ビルドスクリプトのリファクタリング:** 新しいアーキテクチャを実装するため、`generate-icons.cjs`と`generate-weight-exports.cjs`を完全に書き直す。
3.  **パッケージ分割の実装:** `rounded`と`sharp`パッケージを作成し、ビルドプロセスがそれらを処理できるように設定する。
4.  **設定ファイルの更新:** `rollup.config.mjs`, `tsconfig.json`, ルートの`package.json`を新しいモノレポ構成に合わせて修正する。
5.  **ビルド、テスト、そして公開。**